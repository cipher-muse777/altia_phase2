# 2. CUSTOM ENCRYPTION 
Can you get sense of this code file and write the function that will decode the given encrypted file content.
Find the encrypted file here flag_info and code file might be good to analyze and get the flag.

## SOLTUION 
- the given file revealed that it combined  XOR encryption with a multiplicative cipher with a shared key using the Diffie-Hellman formula
- the XOR key takes the message and mixes it up with the word "trudeau" and reversing the plaintext
- the multiplicative cipher, multiplies each letter by a particular number which was formed using Diffie-Hellman formula 

- so to solve it we must first reverse the multiplication (divide by shared_key × 311) and then reverse the XOR with "trudeau" again
```
 cipher.append(((ord(char) * key*311)))
```
refers to encrypted_number = ASCII_value × key × 311 so to decrypt we must ASCII_value = encrypted_number ÷ (key × 311)

- to solve the xor part we must first reverse the plaintext then we can just use the xor operation again which will simply give the original data back

## FLAG
picoCTF{custom_d2cr0pt6d_66778b34}

## CONCEPTS LEARNED 
- how XOR encryption takes the message and mixes it up using a particular word 

```
semi_cipher = dynamic_xor_encrypt(plain_text, text_key)
```

```
def dynamic_xor_encrypt(plaintext, text_key):
    cipher_text = ""
    key_length = len(text_key)
    for i, char in enumerate(plaintext[::-1]):           **Reverse the string**
        key_char = text_key[i % key_length]              **Get next key letter "t","r","u","d","e","a","u"**
        encrypted_char = chr(ord(char) ^ ord(key_char))  **XOR OPERATION**
        cipher_text += encrypted_char
    return cipher_text  **Returns XOR-scrambled text**
```

- how we can form shared key using Diffie-Hellman formula 
