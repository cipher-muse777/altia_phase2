# 1.BUFFER OVER-FLOW 0
Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.
Additional details will be available after launching your challenge instance.

## SOLUTION
- In the given file, the buffer size was 16
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```
- so as to cause a buffer flow as the challenge name suggests, we have to input something that had a length of more than 16, thus causing sigsegv_handler() to print the flag.

  <img width="1210" height="169" alt="Screenshot 2025-10-30 011146" src="https://github.com/user-attachments/assets/1fbde758-f734-4da1-90c2-7ee7cbe754d2" />

## FLAG
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}

## CONCEPTS LEARNED 
- A buffer overflow is a software vulnerability that occurs when a program attempts to write more data into a fixed-size block of memory, or "buffer," than it was designed to hold. This extra data spills over into adjacent memory locations, overwriting and corrupting other data.

## RESOURCES
https://www.fortinet.com/resources/cyberglossary/buffer-overflow
https://www.geeksforgeeks.org/cpp/buffer-overflow-attack-with-example/

# 2.FORMAT STRING 0
Can you use your knowledge of format strings to make the customers happy?
Download the binary here.
Download the source here.
Additional details will be available after launching your challenge instance.

## SOLUTION 
- based on the hint given "This is an introduction of format string vulnerabilities. Look up "format specifiers" if you have never seen them before." i searched up format string vulernabilites" to find, Format string vulnerabilities occur when user-controlled input is unsafely passed as a format string to functions like printf() in C/C++. This can lead to unintended behavior, such as reading or writing arbitrary memory, potentially allowing attackers to execute malicious code.
- the given code, Uses printf(choice1) and printf (choices2) - format string vulnerability becuase they directly use input fro user in printf() causing it to be treated as a code
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 32
#define FLAGSIZE 64

char flag[FLAGSIZE];

void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}

int on_menu(char *burger, char *menu[], int count) {
    for (int i = 0; i < count; i++) {
        if (strcmp(burger, menu[i]) == 0)
            return 1;
    }
    return 0;
}

void serve_patrick();

void serve_bob();


int main(int argc, char **argv){
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL) {
        printf("%s %s", "Please create 'flag.txt' in this directory with your",
                        "own debugging flag.\n");
        exit(0);
    }

    fgets(flag, FLAGSIZE, f);
    signal(SIGSEGV, sigsegv_handler);

    gid_t gid = getegid();
    setresgid(gid, gid, gid);

    serve_patrick();
  
    return 0;
}

void serve_patrick() {
    printf("%s %s\n%s\n%s %s\n%s",
            "Welcome to our newly-opened burger place Pico 'n Patty!",
            "Can you help the picky customers find their favorite burger?",
            "Here comes the first customer Patrick who wants a giant bite.",
            "Please choose from the following burgers:",
            "Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice1[BUFSIZE];
    scanf("%s", choice1);
    char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
    if (!on_menu(choice1, menu1, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        int count = printf(choice1);
        if (count > 2 * BUFSIZE) {
            serve_bob();
        } else {
            printf("%s\n%s\n",
                    "Patrick is still hungry!",
                    "Try to serve him something of larger size!");
            fflush(stdout);
        }
    }
}

void serve_bob() {
    printf("\n%s %s\n%s %s\n%s %s\n%s",
            "Good job! Patrick is happy!",
            "Now can you serve the second customer?",
            "Sponge Bob wants something outrageous that would break the shop",
            "(better be served quick before the shop owner kicks you out!)",
            "Please choose from the following burgers:",
            "Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice2[BUFSIZE];
    scanf("%s", choice2);
    char *menu2[3] = {"Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"};
    if (!on_menu(choice2, menu2, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        printf(choice2);
        fflush(stdout);
    }
}

```
- so after launching instance for the first choice of burgers i put Gr%114d_Cheese since it has %114d since it started with a format specifier with 114 as the minimum field width and d refering to integer
- for second choice i chose "Cla%sic_Che%s%steak becuase %s is a standard format specifier and reads a memory address from the stack and print the string at that location

Screenshot 2025-10-30 012512

## FLAG
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_ef312157}

## CONCEPTS LEARNED 
- Format string exploitation is a type of vulnerability that arises when user-controlled input is improperly handled in functions that use format strings, such as printf() in C. This can lead to unintended behavior, including information disclosure, memory corruption, or even arbitrary code execution.
- %x - reads from the stack
- %s - reads from memory addresses
- %n - writes to memory addresses
- %p - leaks pointers%p - leaks pointers

## RESOURCES 
https://axcheron.github.io/exploit-101-format-strings/
https://ctf101.org/binary-exploitation/what-is-a-format-string-vulnerability/
